### Data-Structures-and-Algorithms:


1. Arrays and hashing
2. Stack
3. Monotonic stack
4. Two pointer
5. Binary search
6. Sliding window
7. Linked list
8. Binary search tree: dfs
9. Binary search tree: bfs
10. Tries
11. Backtracking
12. Heap: priority queue
13. Graphs
14. Dynamic programming
15. Intervals
16. Greedy
17. Bit manipulations

<sub>
<table>
  <tr><td>Sets and probability theory</td><td>Sets fundamentals<br>Combinatorics fundamentals<br>Probability theory fundamentals</td></tr>
  <tr><td>Binary numeral system</td><td>Numeral systems<br>Decimal to binary and vice versa<br>Negative integers binary form<br>Binary summation &amp; multiplication<br>Binary subtraction<br>Floating point binary representation</td></tr>
  <tr><td>Bit manipulations</td><td>Random access memory addressing<br>Big &amp; little endian<br>Binary operations<br>Function’s arguments compression<br>Bit vector</td></tr>
  <tr><td>Stack and queue</td><td>History of stack invention<br>Stack in x86 CPU<br>Stack overflow<br>Tracing<br>Stack frame</td></tr>
  <tr><td>Encodings and strings</td><td>Ascii<br>Single and double byte character set<br>Unicode<br>Utf-8<br>Utf-16<br>Utf-32<br>C-string<br>P-string<br>Immutable string<br>Stringbuilder</td></tr>
  <tr><td>Recursion</td><td>Skeleton of simple recursive function<br>7 rules of creating recursive function<br>Function with 2 recursive calls<br>Tree of recursive function calls<br>Recursion inside the loop</td></tr>
  <tr><td>Algorithms complexity (Big O notation)</td><td>Complexity evaluation<br>Complexity cases<br>Big O notation<br>Log N complexity<br>Strings and complexity evaluation<br>Recursion complexity evaluation<br>Amortized analysis<br>Space complexity</td></tr>
  <tr><td>Array and linked list</td><td>Array types<br>Linked list<br>Linked list operations<br>Linked list implementation<br>Double linked list implementation<br>Search operation<br>Insert operation<br>Delete operation<br>Runner approach</td></tr>
  <tr><td>Hash function</td><td>Associative array<br>Hash function<br>Mod vs multiplication<br>Hash function problems<br>Negative hash<br>Hash and bucket index problem<br>Hash and bucket index calculation rules</td></tr>
  <tr><td>Hash table</td><td>Hash tables types<br>Separate chaining with linked lists<br>Load factor<br>Separate chaining with linked lists complexity<br>Linear probing<br>Quadratic probing<br>Double hashing<br>Open addressing complexity<br>Universal hashing</td></tr>
  <tr><td>Backtracking and dynamic programming</td><td>Return complex value from recursion<br>Backtracking<br>Brute force task<br>CPU, recursion and stack<br>Risks of recursive functions<br>Recursion to iteration<br>Dynamic programming<br>Knapsack problem<br>Head and tail recursion</td></tr>
  <tr><td>Binary search tree</td><td>Search and sort problem<br>Binary tree and binary search tree<br>Insert and search operations<br>Binary search tree traversals<br>Delete operation</td></tr>
  <tr><td>AVL tree</td><td>AVL tree definition<br>How to find place for a new node in AVL tree<br>Tree balancing<br>Height of the tree<br>Unbalanced tree<br>Balance factor<br>Tree rotations<br>Number of balancing operations after node insertion<br>Delete operation</td></tr>
  <tr><td>Red black tree</td><td>Red black tree definition<br>Types of nodes<br>Red black tree rules<br>Why red black tree works<br>Insert operation<br>Delete operation</td></tr>
  <tr><td>Complete binary tree, heap, prefix tree</td><td>Complete binary tree definition<br>Binary heap definition<br>Heap search operation<br>Heap insert operation<br>Heap insert operation amortized complexity<br>Heap extract operation<br>Heappify operation<br>Prefix tree definition<br>Prefix tree insert operation<br>Prefix tree search operation<br>Prefix tree delete operation</td></tr>
  <tr><td>Fundamental sorting</td><td>Sorting complexity evaluation features<br>Bubble sort<br>Selection sort<br>Insertion sort<br>Quadratic sorting comparison<br>Merge sort<br>Heap sort<br>Radix sort</td></tr>
  <tr><td>Hoare’s quick sort</td><td>Partitioned array<br>Array partitioning task<br>Pivot index<br>Destination between left and right pointers<br>Partition function optimization<br>Hoare partition visualization<br>Hoare’s quick sort<br>Hoare’s quick sort complexity</td></tr>
  <tr><td>Lomuto’s quick sort. External sort. Binary search</td><td>Lomuto’s quick sort<br>Lomuto’s quick sort complexity<br>How to speed up quick sort<br>External sort<br>Binary search</td></tr>
  <tr><td>Graphs</td><td>Graph types<br>Depth first search<br>Find path in graph<br>Find cycle in graph<br>Topological sort<br>Depth first search complexity<br>Breadth first search<br>Find shortest path<br>Bidirectional breadth first search<br>Simple and bidirectional breadth first search complexity<br>Dijkstra’s algorithm</td></tr>
</table>
</sub>


