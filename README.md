### Data-Structures-and-Algorithms:


1. Arrays and hashing
2. Stack
3. Monotonic stack
4. Two pointer
5. Binary search
6. Sliding window
7. Linked list
8. Binary search tree: dfs
9. Binary search tree: bfs
10. Tries
11. Backtracking
12. Heap: priority queue
13. Graphs
14. Dynamic programming
15. Intervals
16. Greedy
17. Bit manipulations

<sub>

<table>
  <thead>
    <tr>
      <th>Topic</th>
      <th>Subtopics (Themes)</th>
    </tr>
  </thead>
  <tbody>
    <tr><td><b>Sets and probability theory</b></td><td>Sets fundamentals | Combinatorics fundamentals | Probability theory fundamentals</td></tr>
    <tr><td><b>Binary numeral system</b></td><td>Numeral systems | Decimal to binary and vice versa | Negative integers binary form | Binary summation &amp; multiplication | Binary subtraction | Floating point binary representation</td></tr>
    <tr><td><b>Bit manipulations</b></td><td>Random access memory addressing | Big &amp; little endian | Binary operations | Function’s arguments compression | Bit vector</td></tr>
    <tr><td><b>Stack and queue</b></td><td>History of stack invention | Stack in x86 CPU | Stack overflow | Tracing | Stack frame</td></tr>
    <tr><td><b>Encodings and strings</b></td><td>Ascii | Single and double byte character set | Unicode | Utf-8 | Utf-16 | Utf-32 | C-string | P-string | Immutable string | Stringbuilder</td></tr>
    <tr><td><b>Recursion</b></td><td>Skeleton of simple recursive function | 7 rules of creating recursive function | Function with 2 recursive calls | Tree of recursive function calls | Recursion inside the loop</td></tr>
    <tr><td><b>Algorithms complexity (Big O notation)</b></td><td>Complexity evaluation | Complexity cases | Big O notation | Log N complexity | Strings and complexity evaluation | Recursion complexity evaluation | Amortized analysis | Space complexity</td></tr>
    <tr><td><b>Array and linked list</b></td><td>Array types | Linked list | Linked list operations | Linked list implementation | Double linked list implementation | Search operation | Insert operation | Delete operation | Runner approach</td></tr>
    <tr><td><b>Hash function</b></td><td>Associative array | Hash function | Mod vs multiplication | Hash function problems | Negative hash | Hash and bucket index problem | Hash and bucket index calculation rules</td></tr>
    <tr><td><b>Hash table</b></td><td>Hash tables types | Separate chaining with linked lists | Load factor | Separate chaining with linked lists complexity | Linear probing | Quadratic probing | Double hashing | Open addressing complexity | Universal hashing</td></tr>
    <tr><td><b>Backtracking and dynamic programming</b></td><td>Return complex value from recursion | Backtracking | Brute force task | CPU, recursion and stack | Risks of recursive functions | Recursion to iteration | Dynamic programming | Knapsack problem | Head and tail recursion</td></tr>
    <tr><td><b>Binary search tree</b></td><td>Search and sort problem | Binary tree and binary search tree | Insert and search operations | Binary search tree traversals | Delete operation</td></tr>
    <tr><td><b>AVL tree</b></td><td>AVL tree definition | How to find place for a new node in AVL tree | Tree balancing | Height of the tree | Unbalanced tree | Balance factor | Tree rotations | Number of balancing operations after node insertion | Delete operation</td></tr>
    <tr><td><b>Red black tree</b></td><td>Red black tree definition | Types of nodes | Red black tree rules | Why red black tree works | Insert operation | Delete operation</td></tr>
    <tr><td><b>Complete binary tree, heap, prefix tree</b></td><td>Complete binary tree definition | Binary heap definition | Heap search operation | Heap insert operation | Heap insert operation amortized complexity | Heap extract operation | Heappify operation | Prefix tree definition | Prefix tree insert operation | Prefix tree search operation | Prefix tree delete operation</td></tr>
    <tr><td><b>Fundamental sorting</b></td><td>Sorting complexity evaluation features | Bubble sort | Selection sort | Insertion sort | Quadratic sorting comparison | Merge sort | Heap sort | Radix sort</td></tr>
    <tr><td><b>Hoare’s quick sort</b></td><td>Partitioned array | Array partitioning task | Pivot index | Destination between left and right pointers | Partition function optimization | Hoare partition visualization | Hoare’s quick sort | Hoare’s quick sort complexity</td></tr>
    <tr><td><b>Lomuto’s quick sort. External sort. Binary search</b></td><td>Lomuto’s quick sort | Lomuto’s quick sort complexity | How to speed up quick sort | External sort | Binary search</td></tr>
    <tr><td><b>Graphs</b></td><td>Graph types | Depth first search | Find path in graph | Find cycle in graph | Topological sort | Depth first search complexity | Breadth first search | Find shortest path | Bidirectional breadth first search | Simple and bidirectional breadth first search complexity | Dijkstra’s algorithm</td></tr>
  </tbody>
</table>

</sub>
